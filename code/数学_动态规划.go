package code

// MyIsPalindrome /*****************************9.回文数start******************************/
// 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
// 示例 1:
// 输入: 121
// 输出: true
// 示例2:
// 输入: -121
// 输出: false
// 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
// 示例 3:
// 输入: 10
// 输出: false
// 解释: 从右向左读, 为 01 。因此它不是一个回文数
// */
func MyIsPalindrome(x int) bool {
	// 负数翻转不会相同,直接pass
	if x < 0 {
		return false
	}

	//弹出最后一位数,每次都乘10,组成新int
	var newX, tmp, oldX int
	oldX = x
	for x != 0 {
		tmp = x % 10
		newX = newX*10 + tmp
		x = x / 10
	}

	return newX == oldX
}

/*****************************9.回文数end******************************/

/*****************************69.求x的算术平方根******************************/
/*
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

示例 1：

输入：x = 4
输出：2
示例 2：

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
*/
func mySqrt(x int) int {
	if x == 0 {
		return 0
	}

	left, right := 1, x
	for {
		mid := left + (right-left)/2
		if mid > x/mid {
			right = mid - 1
		} else {
			if mid+1 > x/(mid+1) {
				return mid
			}
			left = mid + 1
		}
	}
}

/*****************************69.求x的算术平方根******************************/

//ClimbStairs /*****************************70.爬楼梯******************************/
/*
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：
	输入：n = 2
	输出：2
	解释：有两种方法可以爬到楼顶。
	1. 1 阶 + 1 阶
	2. 2 阶

示例 2：
	输入：n = 3
	输出：3
	解释：有三种方法可以爬到楼顶。
	1. 1 阶 + 1 阶 + 1 阶
	2. 1 阶 + 2 阶
	3. 2 阶 + 1 阶

1 <= n <= 45
*/
func ClimbStairs(n int) int {
	// n-2阶的方法数 + n-1阶的方法数 = n阶的方法数
	/*
		动态规划5部曲:
		1.确定dp[i]: dp[i]表示上第i个台阶有几种方法  [1,1,2,3,5,8,13...]
		2.得出递推公式: dp[i] = dp[i-1] + dp[i-2]
		3.dp数组初始化: dp[0] = 1 (不用爬,有一种方法..), dp[1] = 1, dp[2] = 2
		4.确定遍历顺序: 需要从数组开头向结尾遍历，才能保证 dp[i] = dp[i-1] + dp[i-2]
		5.打印 dp 数组 (用来debug, 可用test代替)
	*/

	if n <= 2 {
		return n
	}

	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1
	dp[2] = 2

	for i := 3; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}

/*****************************70.爬楼梯******************************/

//Fib *****************************509.斐波那契数******************************/
/*
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列。
该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

示例 1：
	输入：n = 2
	输出：1
	解释：F(2) = F(1) + F(0) = 1 + 0 = 1

示例 2：
	输入：n = 3
	输出：2
	解释：F(3) = F(2) + F(1) = 1 + 1 = 2

示例 3：
	输入：n = 4
	输出：3
	解释：F(4) = F(3) + F(2) = 2 + 1 = 3

提示：
0 <= n <= 30
*/
func Fib(n int) int {
	/*
		动态规划5部曲:
		1.确定dp[i]: dp[i]表示第i个斐波那契数  [0,1,1,2,3,5,8...]
		2.得出递推公式: dp[i] = dp[i-1] + dp[i-2]
		3.dp数组初始化: dp[0] = 0, dp[1] = 1
		4.确定遍历顺序: 需要从数组开头向结尾遍历，才能保证 dp[i] = dp[i-1] + dp[i-2]
		5.打印 dp 数组 (用来debug, 可用test代替)
	*/

	if n <= 1 {
		return n
	}

	//// dp数组初始化, 从 0-n 有n+1个元素
	//dp := make([]int, n+1)
	//dp[0] = 0
	//dp[1] = 1
	//
	//// 遍历
	//for i := 2; i <= n; i++ {
	//	dp[i] = dp[i-1] + dp[i-2]
	//}
	//return dp[n]

	// 优化，不用数组，只需要两个变量来记录 dp[i-1] 和 dp[i-2]
	var sum, one, two int
	one = 0
	two = 1

	for i := 2; i <= n; i++ {
		sum = one + two
		one = two
		two = sum
	}
	return sum
}

// 递归版本, 效率没有上面非递归的高
func fibTwo(n int) int {
	if n <= 1 {
		return n
	}

	// 把 n-1 和 n-2 算出来进行再相加
	return fibTwo(n-1) + fibTwo(n-2)
}

/*****************************509.斐波那契数******************************/
